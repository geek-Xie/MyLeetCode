#### java（语言）

**1.java创建线程和终止线程的几种方法？**

java创建线程的方法基本上有两种。一种是使得线程类继承Thread类并重写run方法来实现；第二种是实现Runnable接口并重写run方法来实现。在实现的时候因为java的单继承机制与在资源共享的角度上考虑更推荐使用实现Runnable接口的方法来实现多线程并发。

java终止线程的方法有三种。第一种是设置一个终止退出的标志位，将线程执行的任务放置在一个while循环中，并将标志位的值作为控制while循环的条件以此来实现对线程活动的控制。第二种是使用interrupt方法来终止线程。第三种是使用stop方法来终止线程。值得注意的是使用stop方法来终止线程的方法已经不推荐使用了，因为使用stop方法会释放子线程持有的所有锁，导致该线程的锁突然的释放，被保护的数据就有可能呈现出不一致性。



**2.java线程的生命周期？**

一个线程不是被创建之后就能立马运行，也不是一直处于执行的状态。在线程的整个生命周期中会经历新建（New），就绪（Runnable），运行（Running），阻塞（Blocked）和销毁（Terminated）五种状态。

使用new关键字创建出来一个线程对象之后，该线程就处于新建状态，此时jvm为其分配内存并初始化成员变量的值。

当线程对象调用start()方法之后，线程处于就绪状态，jvm为其创建方法调用栈和程序计数器，等待CPU的运行。

如果处于就绪状态的线程获得了CPU的时钟，就开始执行run()方法，该线程处于运行状态。

阻塞状态是因为某种原因线层放弃了CPU的使用权。一般由三种原因：第一是运行状态的线程执行了wait()方法，jvm将该线程放入等待队列中；第二种原因是在获取对象的同步锁时，该同步锁被其他线程占用，jvm把该线程放入锁池；第三种是其他的IO阻塞。

如果线程执行完毕后或线程被提前强制性终止或者出现异常，那么线程就被销毁，释放资源。



**3.线程的常用方法？**

wait：强迫一个线程等待，只有等待另一个线程通知或者中断才会返回。调用wait()方法后会释放对象的锁，因此wait一般用在同步方法或同步代码中。

sleep：强迫一个线程睡眠一段时间（毫秒）只有等待另一个线程通知或者中断才会返回。sleep()方法不会释放对象当前占有的锁。

yield：使当前线程让出CPU时间片，与其他线程重新竞争CPU。

interrupt：中断一个线程。注意这个方法不会改变线程的状态，而是影响这个线程内部的一个中断标识位。

join：使当前的线程转为阻塞的状态，直到另一个线程结束，当前线程再有阻塞变为就绪状态。





**4.sleep()和wait()的区别？**

所属的类不同，sleep()属于Thread类，wait()属于Object类；

锁状态不同，sleep()不会释放锁，wait()会释放锁；

再次运行的状态不同，sleep()方法导致线程暂时停止执行，让出CPU，但是他的状态依然保持着，到了该运行的时间又会自动恢复运行状态。wait()只有针对此对象调用notify()方法后，本线程才进入锁定池获取对象锁进入运行状态。





**5.java默认提供的几类线程池？**

newCachedThreadPool：创建一个可缓存的线程池，线程池容量为无限大，当第二个任务开始时第一个任务已经完成，则复用之前的线程，不会创建新线程，可灵活回收线程。

newFixedThreadPool：创建一个有固定代销的线程池，可控制最大并发数（线程数量），超出的线程会在等待队列中等待。

newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。

newSingleThreadExecutor：创建一个单线程化的线程池，它只有唯一的一个工作线程来执行任务，所有任务都只能按照指定的顺序执行。





**6.创建线程池的正确姿势？**

使用java默认提供的线程池的创建方法是可以选择的方案，但是在有的时候会出现内存溢出的错误。

```java
// 创建对应功能的线程池
ExecutorService executor1 = Executors.newCachedThreadPool();
ExecutorService executor2 = Executors.newFixedThreadPool(2);
ExecutorService executor3 = Executors.newScheduledThreadPool(4);
ExecutorService executor4 = Executors.newSingleThreadExecutor();

// 调用线程池执行相应任务
executor1.execute(new Runnable() {
    @Override
    public void run() {
        for (int i = 0; i < 100000; i++) {
            System.out.println(Thread.currentThread().getName() + "  执行  " + i);
        }
    }
});
```

如果我们使用java默认提供的Executors创建线程池。
当我们创建FixedThreadPool 和 SingleThreadExecutor的时候，因为默认的创建方法的参数中阻塞队列的长度为Integer.MAX_VALUE，这就会导致当任务数量很多的时候队列堆积大量的任务请求造成内存溢出(OOM)。
当我们创建CachedThreadPool 和 ScheduledThreadPool的时候，因为默认的创建方法的参数中核心线程的大小为Integer.MAX_VALUE，这就会导致当任务数量很多的时候创建大量的线程，造成内存溢出(OOM)。
上面两个问题的核心就是在于默认提供的参数大小往往不是合适的，因此才建议我们使用new ThreadPoolExecutor的方法创建线程池，并手动初始化各参数。



推荐的创建线程池的方式：

```java
ExecutorService executorService = new ThreadPoolExecutor(10, 10, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue<>(10));
```

即使用new ThreadPoolExecutor()并自己初始化响应的参数。下面介绍一下各个参数的意义。

ThreadPoolExecutor的构造函数：

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```

corePoolSize：线程池核心线程数量，也就是即使空闲也不会被销毁的线程。

maximumPoolSize：线程池最大线程数量。

keepAliveTime：空闲线程存活时间，如果当前线程处于空闲状态且线程数量大于corePoolSize，那么这个线程将会被销毁。

unit：keepAliveTime的计量单位。

BlockingQueue：阻塞队列，即当一个任务进入到线程池后如果现在没有空闲的核心线程，就会被添加到阻塞队列中等待直到有核心线程空闲。而当阻塞队列也满了之后才会调用核心线程之外，最大线程之内的空闲线程。





**7.线程池的拒绝策略？**

当线程池中的等待队列和最大空闲线程都满了的时候，就会执行事先设定好的拒绝策略，java提供了4种拒绝策略。

1.CallerRunsPolicy：该策略下，在调用者线程中直接执行被拒绝任务的run()方法，如果线程池已经shutdown，则直接抛弃任务。

2.AbortPolicy：该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。

3.DiscardPolicy：该策略下，直接丢弃任务，什么都不做。

4.DiscardOldestPolicy：该策略下，抛弃队列最早的那个任务，然后尝试把这次拒绝的任务放入队列中。





**8.锁升级过程？**

java的锁升级是针对Synchronized关键字进行的一种性能优化。在java 5之前每次Synchronized关键字获取的都是重量级锁，造成的资源浪费和消耗非常大。java 5之后添加了锁升级的过程。过程为偏向锁，轻量级锁和重量级锁。

偏向锁：当一段代码被一个线程所访问的时候，该线程就会自动获取锁，降低获取锁的代价。

轻量级锁：当一个锁是偏向锁的时候，有另一个线程申请访问这段代码，偏向锁会升级为轻量级锁。这个申请访问的线程会通过自旋的方式来申请获得这个锁，不会阻塞，提高性能。

重量级锁：当一个所是轻量级锁的时候，并且当另一个线程的自旋次数达到一定次数的时候还没有获得该锁，就会进入阻塞，这个锁就会膨胀为重量级锁。此时线程阻塞，性能降低。

* 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。







**9.CAS和所引发的ABA问题？**

CAS指的是Compare And Swap，是一种基于乐观锁原理的操作。当多个线程同时使用CAS操作一个变量的时候，只有一个会胜出，其他的失败，失败的线程并不会被挂起，仅被告知失败。

实现：CAS包含3各参数V，E，N。V表示要更新的变量，E表示旧值，N表示新值。当且仅当V值等于E值的时候，才会将V的值设为N；如果V值和E值不同，则说明已经有其他的线程做了更新，则当前线程什么都不做。

ABA问题：当两个线程同时在取得V处的值A时，其中一个线程先将原先的A值修改为B，再将B修改为A，并重新写道V处，这时第一个线程看到的是V处的值并没有发生改变，并且认为V处的值没有发生过改变。因此ABA问题使得当前线程的CAS无法判断当前的值是否发生过变化。

解决ABA问题的方法：可以通过实现版本号的方式来解决ABA问题，即在每一次对值进行修改的时候都带上一个版本号。一旦版本号和当前数据的版本号不一致，就可以判断数据是否被修改过。





**10.volatile关键字的作用？**

volatile关键字的作用有两个：实现内存可见性和禁止指令重排序。因此volatile是作为一个轻量级的锁，常用于修饰标记变量以及双重加锁的场景。

实现内存可见性：在java中，每一个内存都是有一个自己独立的内存区域的，因此线程对于数据的处理都是在自己独立的内存区域里进行，而不是直接在主内存中进行，这也是多线程容易造成数据不一致的一个原因。使用volatile修饰变量之后，线程对于该数据的修改就会直接写入主内存中，而读取的时候则会禁止在线程自身的内存中读取而是直接在主内存中读取。即另一个线程可以在第一时间得知其他线程对该数据的修改情况。

禁止指令重排序：jvm通常情况下会对一些指令的汇编语言指令进行重排序（在不影响执行效果的情况下），在单线程的情况下，这会在一定程度提高虚拟机的执行效率，但是在多线程的环境下这有时候会带来一些问题。而是用volatile可以使得jvm禁用指令重排的功能，保证底层指令按序执行。







**11.使用Lock和synchronized的区别？**

首先synchronized是java的一个关键字，属于jvm层面的锁。而Lock是一个类。synchronized对于锁的控制基本上都是由jvm完成的，而Lock使我们对锁的控制权限更高。

而之所以使用Lock更多的是因为synchronized有着一些使用弊端。synchronized锁一般比较沉重，当一个代码块被上了synchronized锁之后，除非代码执行完毕或者出现异常，不然是不会释放锁的。而且对于一些只读线程，完全可以让多个线程同时进行读操作，而这对于synchronized来说都是没有区别的，而Lock可以对线程的访问权限进行查询的。因此采用synchronized会造成效率低下。

synchronized的优点是不需要程序员手动对锁进行释放，当方法或者代码块执行完毕时，系统会自动让线程释放对锁的占用。而Lock需要用户手动释放锁，如果没有手动释放锁，会导致出现死锁的现象。在资源竞争不激烈的情况下，两者的效率是差不多的，但当资源竞争比较激烈的时候，使用Lock的效率会明显的更高。





**12.引用的几种类别？**

jdk1.2之后出现了四种强弱不同的引用：强引用，软引用，弱引用，虚引用。

强引用：就是最传统的“引用”的定义。是指在程序代码中普遍存在的引用赋值，即new关键字。无论何时，只要强引用存在，在虚拟机的垃圾回收过程中都不会作为被回收的对象。

软引用：用来描述一些还有用，但是并非必须存在的对象。在系统将要发生内存溢出之前，会把这些软引用的对象列入回收的范围进行回收。如果这次回收之后还是没有足够的内存，才会抛出异常。

弱引用：与软引用的定义类似，但是比软引用更弱。被弱引用的对象只能生存到下一次垃圾回收为止，当垃圾回收过程开始时，无论内存是否足够，都会回收掉被弱引用的对象。

虚引用：也成为“幽灵引用”和“幻影引用”。无法通过虚引用来取得一个对象的实例。它存在的唯一目的是为了能够在这个对象被垃圾回收的时候收到一个系统的通知。





**13.HashMap？**

详见博客[[HashMap的一些相关](https://segmentfault.com/a/1190000039750674)](https://segmentfault.com/a/1190000039750674)





**14.HashMap，Hashtable和ConcurrentHashMap的区别？**

首先Hashtable和ConcurrentHashMap是线程安全的，而HashMap不是线程安全的。

Hashtable是在HashMap的所有方法上都添加了Synchronized关键字进行加锁来保证线程的安全性，因此带来了效率低下的问题。

Hashtable不允许put的值为null，而HashMap是允许的，因为HashMap做了特殊的处理。

HashMap的初始容量为16，而Hashtable的初始容量为11，负载因子默认都是0.75。扩容时，HashMap是直接容量进行翻倍，而Hashtable是容量翻倍后➕1。

jdk1.7版本的ConcurrentHashMap相比于Hashtable并发度和效率更高的原因是ConcurrentHashMap使用的是分段锁的机制。它不像Hashtable一样需要对整一个Map在每次操作的时候都进行锁住同步，而是将Map分为一个个的Segment，在进行操作的时候只锁住对应的Segment，处于其他Segment的数据可以同时进行处理而不受影响。

jdk1.8版本的ConcurrentHashMap抛弃了分段锁的设定，转而采用CAS+synchronized来实现。即线程同步的最小单位不再是一个segment了，而是单独的一个Node，可以理解为数组的每一个位置都是独立的同步单位，采用synchronized来实现同步。







**15.什么是AQS？**

AQS（AbstractQueuedSynchronizer 抽象队列同步器）是ReentrantLock的底层实现。AQS的内部维护了一个state状态位，尝试加锁的时候通过CAS修改state的值，如果成功则将值值为1，并且把当前线程id赋值，则代表加锁成功。一旦成功获取到了锁，其他的线程将会被阻塞进入阻塞队列自旋。获得锁的线程释放锁之后唤醒阻塞队列里等待的线程，释放锁的时候会把state置为0，同时当前线程ID置为空。

![image-20210403190718309](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210403190718309.png)









**16.ThreadLocal原理是什么？**

ThreadLocal可以理解为线程本地变量，会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间的互相隔离，相比于synchronized的做法是用空间来换取时间。







**17.ArrayList和Vector的区别？**

首先是ArrayList不是线程安全的，而Vector是线程安全的，但是也因此Vector的执行效率比较低。

第二是Vector在扩容时候的新容量是旧容量的2倍，而ArrayList的新容量是旧容量的1.5倍。











**18.Queue接口实现的两组方法？**

| 功能 |  抛异常   |  返回值  |
| :--- | :-------: | :------: |
| 增   |  add(e)   | offer(e) |
| 删   | remove()  |  poll()  |
| 瞧   | element() |  peek()  |

注意使用的时候尽量统一用一组方法。

















#### java（web框架）

**1.Spring Bean 的作用域？**

* singleton：在IOC容器中仅存在一个Bean的实例，Bean以单例的形式存在，默认值；
* prototype：每次从IOC容器中调用Bean的时候，都返回一个新的实例，即每次调用getBean()时候，相当于使用new关键字创建新的实例；
* request：每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境；
* session：同一个HTTP session共享一个Bean，不同的Session使用不同的Bean，仅适用于WebApplicationContext环境；
* globalSession：一般用于Portlet应用环境，还作用域仅适用于WebApplicationContext环境。









**2.Spring IoC初始化过程？**

① Resource定位（Bean的定义文件定位）；

② 将Resource定位好的资源载入到BeanDefinition；

③ 将BeanDefinition注册到容器中；

![img](https://segmentfault.com/img/remote/1460000023067109)









**3.@Component和@Bean的区别是什么？**

* 作用对象不同：@Component注解作用于类，@Bean注解作用于方法；
* @Component通常是通过类路径来自动侦测以及自动装配到Spring容器中。@Bean注解通常是在标有该注解的方法中定义产生这个Bean。
* @Bean比@Component注解的自定义性更强，很多时候只能通过@Bean注解来注册到Bean。











**4.Spring中Bean的生命周期？**

* Bean容器找到配置文件中的Spring Bean定义；
* Bean容器利用Java Reflection API创建一个Bean的实例；
* 如果涉及到一些属性值，利用set()方法进行设置；
* 如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字；
* 如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例；
* 如果Bean实现了BeanFacrotyAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例；
* 与上面的类似，如果实现了其他的接口，调用相应的方法；
* 如果又和加载这个Bean的spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法；
* 如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。
* 如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。
* 如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法
* 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。
* 当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。





















#### golang（语言）





















#### MySQL

**1.数据库的隔离级别？**

* READ UNCOMMITED（读未提交）：这种隔离界别下，读取数据的时候不受任何影响。即你甚至可以读取一个正在被其他事务修改的数据，想读就读，想改就改。这当然开销很小，但是会带来许多的问题，比如“脏读”。即读取到了正在修改但是却还没有提交的数据，这就会造成数据读取的错误。从性能上来说，READ UNCOMMITED不会比其他级别好太多，但是却带来了非常多的麻烦的问题，因此在实际中很少使用这个隔离级别。

* READ COMMITED（提交读/不可重复读）：这个级别在READ UNCOMMITED的基础上添加了一些规定，是MySQL以外的一些数据库的默认隔离级别。它与READ UNCOMMITED的区别在于，它规定读取的时候读到的数据只能是提交后的数据。举个例子，数据a在上一次提交之后的值是1，这时候有一个线程进来对a进行修改，将a修改为2，但是此时并未提交事务（COMMIT），在这种情况下，READ UNCOMMITED级别下读取到的a的值就是当前的2，但是READ COMMITED级别下读取到的还是上一次提交之后的值，即a为1，必须到修改线程将a的值变为2这个事务提交之后读取到的a的值才是2。这个级别所带来的问题就是不可重复读。即上一个时间读取到的a的值是1，但是随着修改线程对事务的提交，a的值变为了2，这时候读到的值就是2了，即执行两次相同的读取操作得到的值却不一样。
  <u>不可重复读同脏读的区别在于，脏读是一个事务读取了另一未完成的事务执行过程中的数据，而不可重复读是一个事务执行过程中，另一事务提交并修改了当前事务正在读取的数据。</u>

* REPEATED READ（可重复读）：REPEATED READ在READ COMMITED的基础上又添加了一些约束性的规则，它也是MySQL数据库的默认隔离级别。简单来说就是在一个事务的执行期间禁止其他事务对相应的数据进行修改，这就彻底使得一个事务的执行过程中所查询到的数据一定是一致的，即解决了脏读和不可重复读的问题，但是却带来了新的问题，即“幻读”。
  “幻读”指的是在一个事务执行过程中虽然禁止了对相应数据的修改，但是其他的事务依然可以插入数据，这时候第一个事务就会发现会“莫名其妙”多出来一些数据，像是出现了幻觉似的。<u>幻读和不可重复读都是读取了另一条已经提交的事务（这点同脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</u>

* SERIALIZABLE（可串行化）：这是最严格的一个隔离级别。它通过强制事务串行执行，避免了幻读的问题。但是这种隔离级别的开销极大，一般也不常使用。

| 隔离级别        | 脏读 | 不可重复读 | 幻读 | 加锁 |
| --------------- | ---- | ---------- | ---- | ---- |
| READ UNCOMMITED | YES  | YES        | YES  | NO   |
| READ COMMITED   | NO   | YES        | YES  | NO   |
| REPEATED READ   | NO   | NO         | YES  | NO   |
| SERIALIZABLE    | NO   | NO         | NO   | YES  |







**2.什么是MVCC？**

试想一下，如果每次SQL操作为了保证数据的一致性与准确性，都需要加一个行级锁的话，非常可靠，但是带来的系统开销与查找效率的下降也是非常明显的，因此MVCC就是为了解决这种矛盾而产生的。
首先MVCC会在表中的每一行记录后面保存两个隐藏的列，一个保存行的创建时间，一个保存行的过期（删除）时间。这个时间值并不是真的时间，而是一个系统版本号。事务开始的时刻的系统版本号作为事务的版本号，用来和查询到的每行记录的版本号进行比较。
INSERT：为新插入的每一行保存当前的系统版本号作为行版本号。
DELETE：为删除的每一行保存当前的系统版本号最为行删除版本号。
UPDATE：更新其实应该理解为插入一条新的数据，并删除原来数据的过程，即为新插入的数据保存当前的系统版本号作为行版本号，并为删除的数据保存当前的系统版本号作为删除版本号。
SELECT：只查询满足下列条件的行：
a.行版本号小于等于事务版本号
b.删除版本号未定义或者大于事务版本号

保存了这两个版本号之后绝大多数的操作都可以在不加锁的情况下进行正确的操作，保证了性能和效率。
<u>值得注意的是MVCC只在READ COMMITED和REPEATABLE READ两个隔离级别下工作。</u>







**3.数据库引擎MyISAM与InnoDB 的区别？**

* InnoDB支持事务，MyISAM不支持。对于InnoDB每一条SQL语言都默认封装成事务，自动提交。
* InnoDB支持外键，MyISAM不支持。所以将一个包含外键的InnoDB表转化为MyISAM会失败。
* InnoDB是聚簇索引，MyISAM是非聚簇索引。
* InnoDB不保存表的具体行数，M有ISAM保存表的行数，因此在查找表的行数的时候，InnoDB需要全表扫描，而MyISAM只需要读出存储的变量即可。
* MyISAM表格可以被压缩之后进行查询操作。
* InnoDB支持表，行（默认）级锁，而MyISAM只支持表级锁。
* InnoDB必须由主键，如果用户没有定义，则自己产生一个隐藏列充当默认主键，MyISAM可以没有主键。







**4.MySQL数据类型钟char和varchar有什么区别？**

varchar属于可变长度的字符串，相对于定长的字符串会更加节省存储空间。当存储数据的时候varchar变量需要在原有的数据大小的基础上额外使用1到2个字节记录字符串的长度。由于长度可变的原因，使得varchar变量在update的时候会更加耗时。在字符串的长度都比较小的时候和列的更新较少的时候使用varchar是更好的选择。

char是定长的字符串，MySQL会根据字符串的长度分配足够的空间，且会在存储数据的时候剔除最后的空格。char类型适合存储长度较短且列的场读基本一致的数据，对于经常变更的数据也适合采用char类型，因为char类型不像varchar类型一样会产生存储碎片的问题。









**5.事务的四大特性（ACID）？**

原子性(atomicity)： 事务的最小工作单元，要么全成功，要么全失败。

一致性(consistency)： 事务开始和结束后，数据库的完整性不会被破坏。

隔离性(isolation)： 不同事务之间互不影响，四种隔离级别为RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE （串行化）。

持久性(durability)： 事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失。









**6.InnoDB和MyISAM上的索引的实现方式有何不同？**

我们知道MyISAM上是非聚簇索引。MyISAM在往表里添加数据的时候，会自动生成一个字段保存当前数据在表中所在的行数。当我们以表格的某一列创建索引的时候，索引中会以这一列的数据进行排序并且保存该列索引的行位置信息（行数），便于快速定位到这一行。可以看出在MyISAM中是否以主键创建索引其实没有区别，所有的索引都是数据+行号的数据组合形式。

在InnoDB中使用的是聚簇索引，这时是否是基于逐渐创建索引就有所区别。InnoDB的主键索引仍然是以主键的数据进行排列，但是不同的是并不仅仅包含逐渐的信息，而是将该主键的整行信息全都包括其中，即找到对应的主键之后不用再通过行号或者指针等其他指标回到表中找到对应信息，而是直接在索引中就能读取。而在非主键索引（二级索引）中，索引按照指定的列数据进行排序后，并没有像主键索引一样存储整个行的信息，而是存储了该行对应的主键的值。这就有点类似于MyISAM中存储了创建索引的数据的值和行号，二级索引是通过对应的主键值去找到对应的行读取数据。

对比MyISAM中的索引和二级索引，首先，存储主键值会比只存储一个指针（行号）带来的空间开销更大。但是当我们的数据表在进行分裂或者其他改变结构操作的时候，存储主键值的索引并不会受到影响，而存储指针的索引，可能就要重新进行更新维护。

![image-20210403121717126](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210403121717126.png)











#### java虚拟机

**1.java虚拟机运行时数据区域情况？**

java虚拟机的数据区域有：程序计数器，虚拟机栈，本地方法栈，堆，方法区，运行时常量池。

程序计数器：线程私有的数据区域，用来记录当前线程执行到的地址位置，方便线程下一次上CPU运行时恢复之前的运行环境。

虚拟机栈，本地方法栈：线程私有的数据区域，由栈帧组成。代码中每调用一个方法就是一个栈帧入栈的过程，方法结束返回就是栈帧出栈的过程。栈帧中保存着局部变量表，操作数栈，动态链接，方法返回地址等数据。栈可以固定大小也可以无限扩展，当大小固定时如果栈帧数量超过栈的深度，则抛出StackOverflowError异常，如果栈的大小可以无限扩展直到超过内存大小，则抛出OutOfMemoryError异常。虚拟机栈保存的是java代码的方法，本地方法栈保存的是Native方法。在jdk1.8之后两者合二为一。

堆：绝大部分实例化对象和数组保存的数据区域，也是垃圾回收机制作用的主要区域，是线程公有的。

方法区：主要存储已经被虚拟机加载的类信息，常量，静态变量的等数据。因不经常参与垃圾回收，又被称为永久代。在jdk1.8之后被移除，使用直接内存中的Metaspace（元数据区）代替。

运行时常量池：jdk1.8前是方法区的一个部分，jdk1.8之后是堆的一部分。用于存放字面量，符号引用和直接引用。

详细解析查看：[[java虚拟机运行时数据区域](https://segmentfault.com/a/1190000039735848)](https://segmentfault.com/a/1190000039735848)









**2.垃圾回收有什么算法？**

标记-清除算法：首先是对内存区域中需要进行回收的区域进行标记，然后再对这些区域进行回收。算法容易实现，但是会造成内存碎片化的问题，因为回收的内存区域往往不是连续的。

标记-复制算法：将内存区域一分为二，每次分配只在一半的内存上进行。回收的时候，将没被回收的内存区域复制后保存到第二个区域，并清空第一个区域。因为垃圾回收后剩余的数据区域往往较少，因此复制过程的消耗不会很大，而且也解决了内存碎片化的问题，因为复制到新区域的内存是连续排列的。但是每次分配的时候只有总内存的一半可以用来进行分配，利用率低。

标记-整理算法：即在标记-清除算法的基础上，对清除过后的内存区域进行移动和整理，使得清除后的内存区域不会呈现碎片化的状态而是连续排列。这种算法适合在数据存活率较高的场景下使用，因为移动整理的代价往往比较大。





**3.如何判断对象是否应该被垃圾回收？**

引用计数法：为每一个对象设置一个引用计数器，每当有一个地方引用它的时候计数器就加1，当一个对象的引用计数器为0时，意味着对象不再被引用，就可以回收。但是因为循环引用的存在导致一些对象的计数器永远不会为0，不会触发垃圾回收过程，而往往这种对象应该被回收，因此这个方法存在缺陷，没有被广泛的应用。

可达性算法：当前应用广泛的判断是否回收的方法。基本思路就是通过一系列被称为“GC Roots”的跟对象作为起始节点集，如果某个对象到GC Roots之间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象已经不可达的时候，则证明这个对象不可能再被使用了。

可以作为GC Roots的对象有：

* 在虚拟机栈（本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用的参数、局部变量、临时变量等。
* 在方法区中类静态属性引用的对象，譬如java类的引用类型静态变量。
* 在方法区中常量引用的对象。
* 在本地方法栈中的Native方法引用的对象。
* java虚拟机内部的引用。
* 所有被同步锁（synchronized关键字）持有的对象。
* 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调，本地代码缓存等。



**4.垃圾回收的过程？**

首先明确基于“分代收集”的堆的内部结构。堆可以分为Eden ，Survivor-0，Survivor-1和Tenured四个世代的区域。当一个对象被实例化后，如果它非常大，则照顾会存储在Tenured（老年代）区域，否则存储在Eden区。在一次GC之后Eden区存活下来的对象就复制到Survivor-0区域中，Survivor-0区域存活下来的复制到Survivor-1中；接下来存活的对象就在Survivor-0和Survivor-1两个中不断复制移动，一定的次数后依然存活的则认为是不易被垃圾回收的对象，将其移动到Tenured区中保留下来。

其中Survivor-0和Survivor-1区域使用的是标记-复制算法，Tenured区中使用的是标记-整理算法。



**5.常见的垃圾收集器及其特点？**

* Serial收集器和ParNew收集器：这两个收集器都是基于标记-复制算法的，比较简单，但是在垃圾回收过程中需要暂停其他线程的运行，即“Stop The World”。唯一的不同点是Serial是单线程的而ParNew是多线程的。
* CMS收集器：是老年代的基于标记-清除的算法实现的收集器。在“STW”问题上有了较大的改进。收集过程分为四步。<u>初始标记</u>，首先标记与GC Roots直接相连的对象；<u>并发标记</u>，从GC Roots直接相连的对象开始遍历整个图，过程较慢，但是不用”Stop The World”；<u>重新标记</u>，修正在并发标记过程中因为用户操作而产生的变动的一些情况；<u>并发清除</u>，即清除之前标记的对象。这些过程只有初始标记和重新标记需要STW停止其他的线程工作，而在最耗时的并发标记环节不用暂停其他的线程，大大降低了垃圾回收过程对系统性能的影响。
* G1收集器：特点是取消了之前收集器的分代的思路，而是面向堆中的任意区域均可进行回收。回收的标准不再局限于它属于哪一个分代，而是哪块内存存放的垃圾最多，回收的受益最大，这就是G1收集器的Mixed GC模式。通过将内存分为一个一个的Region（区域），然后对各个Region的回收价值进行分析排序，以及用户所期望的停顿时间对Region进行有计划的回收。相比于CMS收集器，G1最大的特点就是可以指定最大的停顿时间，但是在内存占用和执行时的负载上都比CMS更高。

注1：在jdk1.9之前默认使用的是ParNew垃圾收集器，在jdk1.9及之后的版本默认使用的是G1垃圾收集器。

注2：在有分代的手机其中最常见的新老区域配合收集器是CMS（老年代）和ParNew（新生代）。









**6.Java虚拟机的类加载机制？**

虚拟机加载类的时机并不是固定的，由虚拟机自己把握。在加载阶段，虚拟机首先通过类的全限定名获取类的二级制字节流，把字节流转换为运行时的数据结构，在内存中生成一个class对象。

能够获得类的全限定名字节流的代码块被成为类加载器，包括了启动类加载器、扩展类加载器、应用程序类加载器和用户自定义类加载器。

![img](https://upload-images.jianshu.io/upload_images/5286333-d8c09312302c4421.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/435/format/webp)

在在家类的过程中，采用双亲委派机制。当一个类加载器需要加载类时，首现委托父类加载器进行加载，并逐级向上，如果父类加载器成功加载则返回成功，如果父类加载器加载失败，则自己进行加载。

值得注意的是在java中类的唯一性是由类和所属的类加载器共同确定的，两个不同的类加载器同时加载同一个类，在虚拟机看来也是不同的类。通过双亲委派机制，能够保证核心类不会被用户覆盖，因为用户企图覆盖核心类时类加载器总能找到已由父类加载器加载的核心类。















#### 网络

**1.Http协议状态码？**

|      | 类别                             | 原因短语                   |
| ---- | -------------------------------- | -------------------------- |
| 1xx  | Information（信息状态码）        | 接受的请求正在处理         |
| 2xx  | Success（成功状态码）            | 请求正常处理完毕           |
| 3xx  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4xx  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5xx  | Server Error（服务端错误状态码） | 服务器处理请求出错         |











**2.在浏览器的地址栏键入网址后会发生一系列什么操作？**

* 解析地址栏键入的URL，识别出web服务器和文件名等元素之后生成HTTP请求；
* 使用DNS进行地址查询，即将URL转化为对应的IP地址以确定HTTP请求要发送的地址；
* 确定了目的IP地址之后，就使用传输层的协议（TCP或者UDP）对HTTP请求进行传输；
* 确定了IP地址之后还需要使用数据链路层协议ARP来确定这个IP地址对应的MAC地址；
* 到达对应的服务器之后，会开始解析发送过来的包，依次去除MAC头部，IP头部，TCP头部，经过层层验证之后得到原生的HTTP请求内容；
* 经过处理之后再依次套上TCP头部，IP头部，MAC头部，并将数据报发还给客户端浏览器，就能显示网页了。






**3.为什么TCP是三次握手而不是两次或者四次？**

TCP的三次握手主要的目的是使得客户端和服务器端都能够对彼此的序号以及连接状态知晓。

因此如果是两次握手，没有第三次握手的情况下，即服务端没有收到客户端发送的第三个报文，服务端是没有办法通过这个报文中的ACK的值来判断客户端是否已经清楚的知晓了服务端的序号的，因此需要第三次握手的报文。

如果是四次握手，这意味着服务端在收到了客户端发送的第一条报文之后，先是向服务端发回了一个ACK的回复报文，告知客户端已收到，再向客户端发送SYN报文告知自己的序号；很显然这时候两步可以合为一步，即在一个报文中包含对客户端的ACK回复与说明自身的序号可以在一步完成，也就是说只需要三次握手即可完成所有功能。



**4.TCP三次握手的具体过程？**

第一次握手：客户机->服务机，SYN位置为1，随机选择一个序号client_isn；
第二次握手：服务机->客户机，SYN位置为1，随机选择一个序号server_isn，ack为client_isn+1，为服务机分配TCP缓存和变量，连接建立；
第三次握手：客户机->服务机，SYN位置为0，为客户机分配TCP缓存和变量，ack为server_isn+1，这个阶段的报文可以携带应用层的相关数据。


**5.GET和POST的区别？**

get把参数包含在url中，post通过requestbody传递参数。
get产生一个数据包，post产生两个数据包。浏览器处理get请求时，会把httpheader和data一起发送出去；post请求则是先发送httpheader等待服务器响应之后再发送data。



















#### 中间件

**1.redis的常用数据结构？**

redis常用的数据结构有：
string：存储的值可以是字符串，整数和浮点数；
list：链表，链表上的每一个节点都包含了一个字符串；
set：包含了字符串的无序集合，并且每个字符串具有不重复性；
hash：键值对；
zset：有序的键值对。